var Joi = require('joi');
var Q = require('q');
var _ = require('lodash');

var Query = require('./Query');

/**
 * Defines a Crud Factory, which is an object responsible for assembling
 * and returning a Crud Object based on an configuration object passed by
 * the user to the library.
 *
 * @class PrototypeFactory
 * @singleton
 */

var CrudFactory = {};

/**
 * Creates the CRUD object to be served to the user
 *
 * @method create
 * @param {Object} ops 			Description of all of the methods of the Crud
 * @param {Mongoose#Model} DAO 	The DAO provided by the user
 * @param {Object} config		The configuration object provided by the user
 * @result {CRUD} Crud			The resulting Crud object
 */
CrudFactory.create = function( ops, DAO, config ){
	// Create a new constructor for Queries
	var Constructor = generateConstructor();

	// Provide its prototype with Crud operations
	_.forOwn( ops, function( operation, key ){
		Constructor.prototype["$" + key] = assembleFunction( operation, DAO, config );
	});

	// Return a new instance of the given prototype
	return new Constructor();
};

CrudFactory.createSubCrud = function( ops, DAO, config ){
	// Create a new constructor for Queries
	var Constructor = generateConstructor();

	// Provide its prototype with Crud operations
	_.forOwn( ops, function( operation, key ){
		Constructor.prototype["$" + key] = assembleFunction( operation, DAO, config );
	});

    return function( crudDocID ){
        // Set the crudDocID of the newly created type to the one
        // provided by the user
        Constructor.prototype.crudDocID = crudDocID;

        // Return an instance of the newly created type
        return new Constructor();
    }
};

function generateConstructor(){
	/*
	* Doing what this code does might seem a little bit of an overkill, but
	* it's necessary. We need to build a new constructor for each Crud so
	* calls to "$where" can safelly return new Queries of the same type of the
	* Crud.
	*/

	// Create a new constructor for Queries
	var Constructor = function(){
		Query.call( this );
	};

	// Give it a prototype that inherit from Query's prototype
	Constructor.prototype = Object.create( Query.prototype );
	Constructor.prototype.constructor = Constructor;

	// Return newly created Constructor
	return Constructor;
}

function assembleFunction( operation, DAO, config ){
	return function( payload ){
		if( operation.payload ){
			var validation = Joi.validate( payload, operation.payload );

			if( validation.error ){
				var deferred = Q.defer();

				deferred.reject( validation.error );

				return deferred.promise;
			}
		}

		// "this.crudDocID" is undefined if the crud isn't a SubCrud.
		return operation.handler( payload, this.query, DAO, this.crudDocID );
	}
}


exports = module.exports = CrudFactory;
