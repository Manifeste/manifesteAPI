var Joi = require('joi');
var q = require('q');
var _ = require('lodash');
var mongoose = require('mongoose');
var ObjectId = mongoose.Types.ObjectId;

var ops = function( description ){
    return {
		create: {
			handler: function( payload, query, DAO, crudDocID ){
                var deferred = q.defer();

                var arrayName = description.attribute;

                payload._id = ObjectId().toString();

                var condition = {
                    _id: crudDocID
                };

                var update = {
                    $push: {}
                };
                update.$push[arrayName] = payload;

                DAO.update(
                    condition,
                    update,
                    function( err, doc ){
                        if( err ){
                            deferred.reject( err );
                        } else {
                            deferred.resolve( payload );
                        }
                    }
                );

                return deferred.promise;
			}
		},
        read: {
            handler: function( payload, query, DAO, crudDocID ){
                var deferred = q.defer();
                var arrayName = description.attribute;
                var docID = arrayName + '._id';

                var match = _.clone( query );
                if( match._id ){
                    match[arrayName+'._id'] = query._id;
                    match = _.omit( match, '_id' );
                }

                DAO
                    .aggregate()
                    .match({
                        _id: ObjectId(crudDocID)
                    })
                    .project( '-_id ' + arrayName )
                    .unwind( arrayName )
                    .match( match )
                    .exec(function( err, res ){
                        if( err ){
                            deferred.reject( err );
                        } else {
                            deferred.resolve( res[0] );
                        }
                    });

                return deferred.promise;
            }
        },
        update: {
            handler: function( payload, query, DAO, crudDocID ){
                var deferred = q.defer();

                deferred.reject( new Error('Not implemented yet') );

                return deferred.promise;
            }
        },
        delete: {
            handler: function( payload, query, DAO, crudDocID ){
                var deferred = q.defer();
                var arrayName = description.attribute;

                var condition = {
                    _id: crudDocID
                };

                var upload = {
                    $pull: {}
                };
                upload.$pull[arrayName] = query;

                var options = {
                    new: false
                };

                DAO
                    .update(
                        condition,
                        upload,
                        options,
                        function( err, doc ){
                            if( err ){
                                deferred.reject( err );
                            } else {
                                var result = _.find( doc[arrayName], query );
                                deferred.resolve( result );
                            }
                        }
                    );

                return deferred.promise;
            }
        },
		query: {
			handler: function( payload, query, DAO, crudDocID ){
                var deferred = q.defer();
                var arrayName = description.attribute;
                var docID = arrayName + '._id';

                DAO
                    .aggregate()
                    .match({
                        _id: ObjectId(crudDocID)
                    })
                    .project( '-_id ' + arrayName )
                    .unwind( arrayName )
                    .match( query )
                    .exec(function( err, res ){
                        if( err ){
                            deferred.reject( err );
                        } else {
                            deferred.resolve( res );
                        }
                    });

                return deferred.promise;
			}
		}
	};
};

exports = module.exports = ops;
