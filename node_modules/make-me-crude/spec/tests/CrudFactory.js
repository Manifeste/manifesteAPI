var Joi = require('joi');
var Q = require('q');
var _ = require('lodash');
var CrudFactory = require('../../lib/CrudFactory');

describe('Crud Factory', function(){
    var operations = {
        test1: {
            handler: function(){
                var deferred = Q.defer();

                deferred.resolve( "called" );

                return deferred.promise;
            },
            payload: Joi.object().keys({
                test: Joi.string().required()
            }).required()
        },
        test2: {
            handler: function(){
                return "called";
            }
        }
    };

    var myCrud = CrudFactory.create( operations );

    it('should have one method for each operation described', function(){
        _.forOwn( operations, function( value, key ){
            expect( typeof myCrud['$' + key] ).toEqual( 'function' );
        });
    });

    it('should redirect valid calls to handler', function(){
        expect( myCrud.$test2() ).toEqual( "called" );
    });

    it('should enforce Joi Schemas', function( done ){
        var jasmine = this;

        myCrud
            .$test1()
            .then(function( obj ){
                jasmine.fail("Invalid payload passed");
            })
            .fail(function( err ){
                expect( err ).not.toBeUndefined();
            })
            .finally(function(){
                done();
            });
    });

    it('should inherit from Query', function(){
        expect( myCrud.$where ).not.toBeUndefined();
    });

    it('should spawn objects capable of reproducing itself', function(){
        var myQuery = myCrud.$where( {sample: "query"} );

        expect( myQuery.constructor ).toEqual( myCrud.constructor );
    });

    it('should spawn objects with different constructors for every call', function(){
        var anotherCrud = CrudFactory.create( operations );

        expect( anotherCrud.constructor ).not.toEqual( myCrud.constructor );
    });
});
